---
layout: page
title: API Documentation
nav_label: api
---

<div class="row no-gutters">
    <div id="doc-col" class="col-md-8">
      {% include versions.html %}

      <h3 id="introduction">Introduction</h3>
      <p>Welcome to the Typesense API documentation. This documentation itself is open source.
        Please leave your feedback as issues on the
        <a href="https://github.com/typesense/typesense-website/issues">GitHub repo</a> or send us a pull-request
        to contribute edits.</p>

      <p><mark>To learn how to install and run Typesense, see our <a href="/guide">getting started guide</a> instead.</mark></p>

      <h3 id="api-clients">API clients</h3>

      <p>At the moment, we have API clients for Javascript, PHP, Python, and Ruby. </p>
      <p>We recommend that you use our API client library if it is available for your language.</p>

      {% code_block install %}
        ```javascript
          // Node.js
          npm install typesense

          // Browser
          <script src="dist/typesense.min.js"></script>
        ```

        ```php
          composer require typesense/typesense-php
        ```

        ```python
           pip install typesense
        ```

        ```ruby
           gem install typesense
        ```
      {% endcode_block %}

      <p>If you're using our Javascript client to access Typesense directly from the browser, be sure to start the
        Typesense server with the <code>--enable-cors</code> flag. </p>

      <h3 id="authentication">Authentication</h3>

      {% code_block authenticate %}
      ```javascript
        /*
         *  Our Javascript client library works on both the server and the browser.
         *  When using the library on the browser, please be sure to use the
         *  search-only API Key rather than the master API key since the latter
         *  has write access to Typesense and you don't want to expose that.
         */
        let client = new Typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'apiKey': '<API_KEY>'
          'connectionTimeoutSeconds': 2
        })
      ```

      ```php
        use Typesense\Client;

        $client = new Client(
          [
            'nodes'        => [
              [
                'host'     => 'localhost',
                'port'     => '8108',
                'protocol' => 'http',
              ],
            ],
            'api_key'      => '<API_KEY>',
            'connection_timeout_seconds' => 2,
          ]
        );
        ```

      ```python
        import typesense

        client = typesense.Client({
          'nodes': [{
            'host': 'localhost',
            'port': '8108',
            'protocol': 'http',
          }],

          'api_key': '<API_KEY>',
          'connection_timeout_seconds': 2
        })
      ```

      ```ruby
        require 'typesense'

        client = Typesense::Client.new(
          nodes: [
            {
              host:     'localhost',
              port:     8108,
              protocol: 'http'
            }
          ],

          api_key:  '<API_KEY>',
          connection_timeout_seconds: 2
        )
      ```

      ```shell
          # API authentication is done via the `X-TYPESENSE-API-KEY` HTTP header.
          curl -H "X-TYPESENSE-API-KEY: <API_KEY>" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h3 id="usage">Usage</h3>

      <p>In Typesense, a group of related documents is called a <code>collection</code>. A <code>collection</code> is roughly
        equivalent to a table in a relational database.
      </p>

      <h4 id="create-collection">Create a collection</h4>

      <p>When a <code>collection</code> is created, we give it a name and describe the fields that will be indexed
        from the documents that are added to the <code>collection</code>.</p>

      <p>
        Your documents can contain other fields not mentioned in the collection's schema - they will be stored but
        not indexed.
      </p>

      {% code_block create-collection %}

      ```javascript
        let schema = {
          'name': 'companies',
          'num_documents': 0,
          'fields': [
            {
              'name': 'company_name',
              'type': 'string',
              'facet': false
            },
            {
              'name': 'num_employees',
              'type': 'int32',
              'facet': false
            },
            {
              'name': 'country',
              'type': 'string',
              'facet': true
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections().create(schema)
      ```

      ```php
        $schema = [
          'name'      => 'companies',
          'fields'    => [
            [
              'name'  => 'company_name',
              'type'  => 'string'
            ],
            [
              'name'  => 'num_employees',
              'type'  => 'int32'
            ],
            [
              'name'  => 'country',
              'type'  => 'string',
              'facet' => true
            ]
          ],
          'default_sorting_field' => 'num_employees'
        ]

        $client->collections->create($schema)
      ```

      ```python
        schema = {
          'name': 'companies',
          'fields': [
            {
              'name'  :  'company_name',
              'type'  :  'string'
            },
            {
              'name'  :  'num_employees',
              'type'  :  'int32'
            },
            {
              'name'  :  'country',
              'type'  :  'string',
              'facet' :  True
            }
          ],
          'default_sorting_field': 'num_employees'
        }

        client.collections.create(schema)
      ```

      ```ruby
        schema = {
          'name'      => 'companies',
          'fields'    => [
            {
              'name'  => 'company_name',
              'type'  => 'string'
            },
            {
              'name'  => 'num_employees',
              'type'  => 'int32'
            },
            {
              'name'  => 'country',
              'type'  => 'string',
              'facet' => true
            }
          ],
          'default_sorting_field' => 'num_employees'
        }

        client.collections.create(schema)
      ```

      ```shell
        curl "http://localhost:8108/collections" -X POST -H "Content-Type: application/json" \
               -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                 "name": "companies",
                 "fields": [
                   {"name": "company_name", "type": "string" },
                   {"name": "num_employees", "type": "int32" },
                   {"name": "country", "type": "string", "facet": true }
                 ],
                 "default_sorting_field": "num_employees"
               }'
      ```
      {% endcode_block %}


      <h5>Sample response</h5>

      {% code_block create-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 0,
          "fields": [
            {"name": "company_name", "type": "string" },
            {"name": "num_employees", "type": "int32" },
            {"name": "country", "type": "string", "facet": true }
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/collections</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>name</td>
          <td>yes</td>
          <td>Name of the collection you wish to create.</td>
        </tr>
        <tr>
          <td>fields</td>
          <td>yes</td>
          <td>
            <p>A list of fields that you wish to index for querying, filtering and faceting. For each field, you
            have to specify the <code>name</code> and <code>type</code>.</p>

            <p><strong>Declaring a field as optional</strong></p>
            <p>A field can be declared as optional by setting <code>"optional": true</code>.</p>

            <p><strong>Declaring a field as a facet</strong></p>

            <p>A field can be declared as a facetable field by setting <code>"facet": true</code>.</p>
            <p>Faceted fields are indexed <strong>verbatim</strong> without any tokenization or preprocessing.
              For example, if you are building a product search, <code>color</code> and <code>brand</code> could be
              defined as facet fields.</p>
          </td>
        </tr>
        <tr>
          <td>default_sorting_field</td>
          <td>yes</td>
          <td>
            <p>The name of an <code>int32</code> / <code>float</code> field that determines the order in which
            the search results are ranked when a <code>sort_by</code> clause is not provided during searching.
              This field must indicate some kind of popularity. For example, in a product search
              application, you could define <code>num_reviews</code> field as the <code>default_sorting_field</code>.
            </p>

            <p>Additionally, when a word in a search query matches multiple possible words (either because of a typo or
              during a prefix search), this parameter is used to rank such equally matching tokens.
              For e.g. both "john" and "joan" are 1-typo away from "jofn". Similarly, in a
              prefix search, both "apple" and "apply" would match the prefix "app".</p>
          </td>
        </tr>
      </table>

      <h5>Supported search field types</h5>

      <p>Typesense allows you to index the following types of fields:</p>

      <table class="table table-striped">
        <tr><td><code>string</code></td></tr>
        <tr><td><code>int32</code></td></tr>
        <tr><td><code>int64</code></td></tr>
        <tr><td><code>float</code></td></tr>
        <tr><td><code>bool</code></td></tr>
      </table>

      <p>You can define an array or multi-valued field by suffixing a <code>[]</code> at the end:</p>

      <table class="table table-striped">
        <tr><td><code>string[]</code></td></tr>
        <tr><td><code>int32[]</code></td></tr>
        <tr><td><code>int64[]</code></td></tr>
        <tr><td><code>float[]</code></td></tr>
        <tr><td><code>bool[]</code></td></tr>
      </table>


      <h4 id="index-document">Index a document</h4>

      <p>A document to be indexed in a given collection must conform to the schema of the collection.</p>

      <p>
        If the document contains an `id` field of type `string`, Typesense would use that field as the identifier for the
        document. Otherwise, Typesense would assign an identifier of its choice to the document.
      </p>

      {% code_block index-document %}

        ```javascript
          let document = {
            'id': '124',
            'company_name': 'Stark Industries',
            'num_employees': 5215,
            'country': 'USA'
          }

          client.collections('companies').documents().create(document)
        ```

        ```php
        $document = [
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        ]

        $client->collections['companies']->documents->create($document)
        ```

        ```python
        document = {
          'id': '124',
          'company_name': 'Stark Industries',
          'num_employees': 5215,
          'country': 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```ruby
        document = {
          'id'            => '124',
          'company_name'  => 'Stark Industries',
          'num_employees' => 5215,
          'country'       => 'USA'
        }

        client.collections['companies'].documents.create(document)
        ```

        ```shell
        curl "http://localhost:8108/collections/companies/documents" -X POST \
                -H "Content-Type: application/json" \
                -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
                -d '{
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }'
        ```
      {% endcode_block %}

      <h5>Sample Response</h5>

      {% code_block index-document-response %}
      ```json
      {
        "id": "124",
        "company_name": "Stark Industries",
        "num_employees": 5215,
        "country": "USA"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents</code></p>

      <h4 id="search-collection">Search a collection</h4>

      <p>In Typesense, a search consists of a query against one or more text fields and a list of filters against numerical or
        facet fields. You can also sort and facet your results.</p>

      {% code_block search-collection %}
      ```javascript
        let searchParameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections('companies').documents().search(searchParameters)
      ```

      ```php
        $searchParameters = [
          'q'         => 'stark',
          'query_by'  => 'company_name',
          'filter_by' => 'num_employees:>100',
          'sort_by'   => 'num_employees:desc'
        ]

        $client->collections['companies']->documents->search($searchParameters)
      ```

      ```python
        search_parameters = {
          'q'         : 'stark',
          'query_by'  : 'company_name',
          'filter_by' : 'num_employees:>100',
          'sort_by'   : 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```ruby
        search_parameters = {
          'q'         => 'stark',
          'query_by'  => 'company_name',
          'filter_by' => 'num_employees:>100',
          'sort_by'   => 'num_employees:desc'
        }

        client.collections['companies'].documents.search(search_parameters)
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
        "http://localhost:8108/collections/companies/documents/search\
        ?q=stark&query_by=company_name&filter_by=num_employees:>100\
        &sort_by=num_employees:desc"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block search-collection-response %}
      ```json
        {
          "facet_counts": [],
          "found": 1,
          "took_ms": 1,
          "hits": [
            {
              "highlights": [
                {
                  "field": "company_name",
                  "snippet": "<mark>Stark</mark> Industries"
                }
              ],
              "document": {
                "id": "124",
                "company_name": "Stark Industries",
                "num_employees": 5215,
                "country": "USA"
              }
            }
          ]
        }
      ```
      {% endcode_block %}

      <p>When a <code>string[]</code> field is queried, the <code>highlights</code> structure would include the
        corresponding matching array indices of the snippets. For e.g:</p>

      {% code_block highlights-arrray-response %}
      ```json
        {
              ...
              "highlights": [
                {
                  "field": "addresses",
                  "indices": [0,2],
                  "snippets": [
                    "10880 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265",
                    "10000 <mark>Malibu</mark> Point, <mark>Malibu,</mark> CA 90265"
                  ]
                }
              ],
              ...
        }
      ```
      {% endcode_block %}

      <h5>Group by</h5>

      <p>You can aggregate search results into groups or buckets by specify one or more <code>group_by</code> fields.</p>

      <p>Grouping hits this way is useful in:</p>

      <ul>
        <li><strong>Deduplication</strong>: By using one or more <code>group_by</code> fields, you can
          consolidate items and remove duplicates in the search results. For example, if there are multiple
          shoes of the same size, by doing a <code>group_by=size&group_limit=1</code>, you ensure that only a
          single shoe of each size is returned in the search results.</li>
        <li><strong>Correcting skew</strong>: When your results are dominated by documents of a particular
          type, you can use <code>group_by</code> and <code>group_limit</code> to correct that skew.
          For example, if your search results for a query contains way too many documents of the same <code>brand</code>,
          you can do a <code>group_by=brand&group_limit=3</code> to ensure that only the top 3 results of each brand
          is returned in the search results.</li>
      </ul>

      <p><mark><strong>NOTE:</strong> To group on a particular field, it must be a faceted field.</mark></p>

      <p>Grouping returns the hits in a nested structure, that's different from the plain JSON response format we saw
        earlier. Let's repeat the query we made earlier with a <code>group_by</code> parameter:</p>

      {% code_block search-group-collection %}

      ```javascript
      let searchParameters = {
        'q'            : 'stark',
        'query_by'     : 'company_name',
        'filter_by'    : 'num_employees:>100',
        'sort_by'      : 'num_employees:desc'
        'group_by'     : 'country'
        'group_limit'  : '1'
      }

      client.collections('companies').documents().search(searchParameters)
      ```

      ```php
      $searchParameters = [
        'q'           => 'stark',
        'query_by'    => 'company_name',
        'filter_by'   => 'num_employees:>100',
        'sort_by'     => 'num_employees:desc'
        'group_by'    => 'country'
        'group_limit' => '1'
      ]

      $client->collections['companies']->documents->search($searchParameters)
      ```

      ```python
      search_parameters = {
        'q'           : 'stark',
        'query_by'    : 'company_name',
        'filter_by'   : 'num_employees:>100',
        'sort_by'     : 'num_employees:desc'
        'group_by'    : 'country'
        'group_limit' : '1'
      }

      client.collections['companies'].documents.search(search_parameters)
      ```

      ```ruby
      search_parameters = {
        'q'           => 'stark',
        'query_by'    => 'company_name',
        'filter_by'   => 'num_employees:>100',
        'sort_by'     => 'num_employees:desc'
        'group_by'    => 'country'
        'group_limit' => '1'
      }

      client.collections['companies'].documents.search(search_parameters)
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/companies/documents/search\
      ?q=stark&query_by=company_name&filter_by=num_employees:>100\
      &sort_by=num_employees:desc&group_by=country&group_limit=1"
      ```
      {% endcode_block %}

      {% code_block search-group-by-collection-response %}
      ```json
      {
        "facet_counts": [],
        "found": 1,
        "took_ms": 1,
        "grouped_hits": [
          {
            "group_key": ["USA"],
            "hits": [
              {
                "highlights": [
                  {
                    "field": "company_name",
                    "snippet": "<mark>Stark</mark> Industries"
                  }
                ],
                "document": {
                  "id": "124",
                  "company_name": "Stark Industries",
                  "num_employees": 5215,
                  "country": "USA"
                }
              }
            ]
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/search</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>q</td>
          <td>yes</td>
          <td>
            <p>The query text to search for in the collection.</p>
            <p>
                Use <code>*</code> as the search string to return all documents. This is typically useful when used in
                conjunction with <code>filter_by</code>.</p>
                <p>For example, to return all documents that match a filter, use: <br/>
                <code>q=*&filter_by=num_employees:10</code> </p>
          </td>
        </tr>
        <tr>
          <td>query_by</td>
          <td>yes</td>
          <td>
            <p>One or more <code>string</code> / <code>string[]</code> fields that should be queried against.
              Separate multiple fields with a comma: <code>company_name, country</code></p>

            <p>The order of the fields is important: a record that matches on a field earlier in the list is
              considered more relevant than a record matched on a field later in the list.
              So, in the example above, documents that match on the <code>company_name</code> field are ranked above
              documents matched on the <code>country</code> field.</p></td>
        </tr>
        <tr>
          <td>prefix</td>
          <td>no</td>
          <td><p>Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole
            word. This is necessary for building autocomplete and instant search interfaces.</p>
            <p>Default: <code>true</code></p>
          </td>
        </tr>
        <tr>
          <td>filter_by</td>
          <td>no</td>
          <td><p>Filter conditions for refining your search results.</p>
              <p>A field can be matched against one or more values.</p>
              <p><code>country: USA</code> <br />
                 <code>country: [USA, UK]</code>
              </p>

              <p>To match a string field exactly, you have to mark the field as a facet and use the
              <code>:=</code> operator.</p>

              <p>
                For example, <code>category:= Shoe</code> will match documents from the
                category <code>shoes</code> and <i>not</i> from a category like
                <code>shoe rack</code>.
                You can also filter using multiple values: <code>category:= [Shoe, Sneaker]</code>.
              </p>

              <p>Separate multiple conditions with the <code>&&</code> operator.</p>
              <p><code>num_employees:>100 && country: [USA, UK]</code></p>

              <p>More examples:</p>

              <p><code>num_employees:10</code> <br />
                 <code>num_employees:<=10</code>
              </p>
          </td>
        </tr>
        <tr>
          <td>sort_by</td>
          <td>no</td>
          <td>
            <p>A list of numerical fields and their corresponding sort orders that will be used for ordering your results.
            Separate multiple fields with a comma. Up to 3 sort fields can be specified.</p>
            <p>E.g. <code>num_employees:desc,year_started:asc</code></p>

            <p>The text similarity score is exposed as a special <code>_text_match</code> field that you can use
            in the list of sorting fields.</p>

            <p>If one or two sorting fields are specified, <code>_text_match</code> is used for
              tie breaking, as the last sorting field.</p>

            <p>Default:</p>

            <p>If no <code>sort_by</code> parameter is specified, results are sorted by:
              <code>_text_match:desc,default_sorting_field:desc</code>.</p>
          </td>
        </tr>
        <tr>
          <td>facet_by</td>
          <td>no</td>
          <td><p>A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.</p></td>
        </tr>
        <tr>
          <td>max_facet_values</td>
          <td>no</td>
          <td><p>Maximum number of facet values to be returned.</p></td>
        </tr>
        <tr>
          <td>facet_query</td>
          <td>no</td>
          <td><p>Facet values that are returned can now be filtered via this parameter. The matching facet text is
            also highlighted. For example, when faceting by <code>category</code>, you can set
            <code>facet_query=category:shoe</code> to return only facet values that contain the prefix "shoe". </p>
          </td>
        </tr>
        <tr>
          <td>num_typos</td>
          <td>no</td>
          <td><p>Number of typographical errors (1 or 2) that would be tolerated.</p>

            <p><a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerau–Levenshtein distance</a>
              is used to calculate the number of errors.</p>

            <p>Default: <code>2</code></p>
          </td>
        </tr>
        <tr>
          <td>page</td>
          <td>no</td>
          <td><p>Results from this specific page number would be fetched.</p></td>
        </tr>
        <tr>
          <td>per_page</td>
          <td>no</td>
          <td>
            <p>Number of results to fetch per page.</p>
            <p>Default: <code>10</code></p>
          </td>
        </tr>
        <tr>
          <td>group_by</td>
          <td>no</td>
          <td><p>You can aggregate search results into groups or buckets by specify one or more
              <code>group_by</code> fields. Separate multiple fields with a comma.</p>
              <p>NOTE: To group on a particular field, it must be a faceted field.</p>
              <p>E.g. <code>group_by=country,company_name</code></p>
          </td>
        </tr>
        <tr>
          <td>group_limit</td>
          <td>no</td>
          <td><p>Maximum number of hits to be returned for every group. If the <code>group_limit</code> is
              set as <code>K</code> then only the top K hits in each group are returned in the response.</p>
              <p>Default: <code>3</code></p>
          </td>
        </tr>
        <tr>
          <td>include_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to include in the search result.</p></td>
        </tr>
        <tr>
          <td>exclude_fields</td>
          <td>no</td>
          <td><p>Comma-separated list of fields from the document to exclude in the search result.</p></td>
        </tr>
        <tr>
          <td>highlight_full_fields</td>
          <td>no</td>
          <td>
            <p>Comma separated list of fields which should be highlighted fully without snippeting.</p>
            <p>Default: all fields will be snippeted.</p>
          </td>
        </tr>
        <tr>
          <td>snippet_threshold</td>
          <td>no</td>
          <td><p>Field values under this length will be fully highlighted, instead of showing a snippet of
              relevant portion.</p>
              <p>Default: <code>30</code></p>
          </td>
        </tr>
        <tr>
          <td>drop_tokens_threshold</td>
          <td>no</td>
          <td>
              <p>
                  If the number of results found for a specific query is less than this number, Typesense will attempt
                  to drop the tokens in the query until enough results are found. Tokens that have the least individual hits
                  are dropped first. Set <code>drop_tokens_threshold</code> to <code>0</code> to disable dropping of tokens.
              </p>
              <p>
                Default: <code>10</code>
              </p>
          </td>
        </tr>
        <tr>
          <td>typo_tokens_threshold</td>
          <td>no</td>
          <td>
            <p>
              If the number of results found for a specific query is less than this number, Typesense will attempt to
              look for tokens with more typos until enough results are found.
            </p>
            <p>
              Default: <code>100</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>pinned_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally include in the search results at specific positions.</p>
            <p>An example use case would be to feature or promote certain items on the top of search results.</p>
            <p>A comma separated list of <code>record_id:hit_position</code>. Eg: to include a record with ID 123 at Position 1
              and another record with ID 456 at Position 5, you'd specify <code>123:1,456:5</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
        <tr>
          <td>hidden_hits</td>
          <td>no</td>
          <td>
            <p>A list of records to unconditionally hide from search results.</p>
            <p>A comma separated list of <code>record_id</code>s to hide. Eg: to hide records with IDs 123 and 456,
              you'd specify <code>123,456</code>.
            </p>
            <p>You could also use the Overrides feature to override search results based on rules.
              Overrides are applied first, followed by pinned_hits and finally hidden_hits.
            </p>
          </td>
        </tr>
      </table>

      <h4 id="retrieve-document">Retrieve a document</h4>

      Fetch an individual document from a collection by using its <code>id</code>.

      {% code_block retrieve-document %}
      ```javascript
        client.collections('companies').documents('124').retrieve()
      ```

      ```php
        $client->collections['companies']->documents['124']->retrieve()
      ```

      ```python
        client.collections['companies'].documents['124'].retrieve()
      ```

      ```ruby
        client.collections['companies'].documents['124'].retrieve
      ```

      ```shell
        $ curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET \
              "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="delete-document">Delete a document</h4>

      <p>Delete an individual document from a collection by using its <code>id</code>.</p>

      {% code_block delete-document %}
      ```javascript
        client.collections('companies').documents('124').delete()
      ```

      ```php
        $client->collections['companies']->documents['124']->delete()
      ```

      ```python
        client.collections['companies'].documents['124'].delete()
      ```

      ```ruby
        client.collections['companies'].documents['124'].delete
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE \
            "http://localhost:8108/collections/companies/documents/124"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-document-response %}
      ```json
        {
          "id": "124",
          "company_name": "Stark Industries",
          "num_employees": 5215,
          "country": "USA"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/documents/:id</code></p>

      <h4 id="retrieve-collection">Retrieve a collection</h4>

      <p>Retrieve the details of a collection, given its name.</p>

      {% code_block retrieve-collection %}
      ```javascript
        client.collections('companies').retrieve()
      ```

      ```php
        $client->collections['companies']->retrieve()
      ```

      ```python
        client.collections['companies'].retrieve()
      ```

      ```ruby
        client.collections['companies'].retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block retrieve-collection-response %}
      ```json
        {
          "name": "companies",
          "num_documents": 1250,
          "fields": [
            {"name": "company_name", "type": "string"},
            {"name": "num_employees", "type": "int32"},
            {"name": "country", "type": "string", "facet": true}
          ],
          "default_sorting_field": "num_employees"
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h4 id="export-documents">Export documents from a collection</h4>

      {% code_block export-documents %}
      ```javascript
        client.collections('companies').documents().export()
      ```

      ```php
        $client->collections['companies']->documents->export()
      ```

      ```python
        client.collections['companies'].documents.export()
      ```

      ```ruby
        client.collections['companies'].documents.export
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X GET
            "http://localhost:8108/collections/companies/documents/export"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block export-documents-response %}
        ```jsonlines
          {"id": "124", "company_name": "Stark Industries", "num_employees": 5215,\
          "country": "US"}
          {"id": "125", "company_name": "Future Technology", "num_employees": 1232,\
          "country": "UK"}
          {"id": "126", "company_name": "Random Corp.", "num_employees": 531,\
          "country": "AU"}
        ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/documents/export</code></p>

      <h4 id="import-documents">Import documents into a collection</h4>

      <p>The documents to be imported must be formatted in a newline delimited JSON stucture.
         You can feed the output file from a Typesense export operation directly as import.</p>

      <p>Here's an example file:</p>

      {% code_block import-documents-err-response %}
      ```jsonl
      {"company_name": "Stark Industries", "num_employees": 5215, "country": "USA"}
      {"company_name": "Orbit Inc.", "num_employees": 256, "country": "UK"}
      ```
      {% endcode_block %}

      <p>You can import the above <code>documents.jsonl</code> file like this.</p>

      {% code_block import-documents %}
      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X POST --data-binary @documents.jsonl \
      "http://localhost:8108/collections/companies/documents/import"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block import-documents-response %}
      ```jsonlines
        {"success": true}
        {"success": true}
      ```
      {% endcode_block %}

      <p>Each line of the response indicates the result of each document present in the request body (in the same order).
        If the import of a single document fails, it does not affect the other documents.</p>

      <p>If there is a failure, the response line will include a corresponding error message and as well as the
        actual document content. For example, the second document had an import failure in the following response:</p>

      {% code_block import-documents-err-response %}
      ```json
        {"success": true}
        {"success": false, "error": "Bad JSON.", "document": "[bad doc"}
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>POST ${TYPESENSE_HOST}/collections/:collection/documents/import</code></p>

      <h4 id="list-collection">List all collections</h4>

      <p>Returns a summary of all your collections. The collections are returned sorted by creation date,
        with the most recent collections appearing first.</p>

      {% code_block list-collection %}

      ```javascript
        client.collections().retrieve()
      ```

      ```php
        $client->collections->retrieve()
      ```

      ```python
        client.collections.retrieve()
      ```

      ```ruby
        client.collections.retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" "http://localhost:8108/collections"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block list-collection-response %}
      ```json
      {
        "collections": [
          {
            "num_documents": 1250,
            "name": "companies",
            "fields": [
              {"name": "company_name", "type": "string"},
              {"name": "num_employees", "type": "int32"},
              {"name": "country", "type": "string", "facet": true}
            ],
            "default_sorting_field": "num_employees"
          },
          {
            "num_documents": 1250,
            "name": "ceos",
            "fields": [
              {"name": "company_name", "type": "string"},
              {"name": "full_name", "type": "string"},
              {"name": "from_year", "type": "int32"}
            ],
            "default_sorting_field": "num_employees"
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>GET ${TYPESENSE_HOST}/collections</code></p>

      <h4 id="drop-collection">Drop a collection</h4>

      <p>Permanently drops a collection. This action cannot be undone. For large collections, this might have an impact on read
        latencies.</p>

      {% code_block drop-collection %}
      ```javascript
        client.collections('companies').delete()
      ```

      ```php
        $client->collections['companies']->delete()
      ```

      ```python
        client.collections['companies'].delete()
      ```

      ```ruby
        client.collections['companies'].delete
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -X DELETE
            "http://localhost:8108/collections/companies"
      ```

      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block drop-collection-response %}
      ```json
      {
        "name": "companies",
        "num_documents": 1250,
        "fields": [
          {"name": "company_name", "type": "string"},
          {"name": "num_employees", "type": "int32"},
          {"name": "country", "type": "string", "facet": true}
        ],
        "default_sorting_field": "num_employees"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>

      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection</code></p>

      <h3 id="api-keys">API Keys</h3>

      <p>Typesense allows you to create API Keys with fine-grain access control. You can restrict access on
      both a per-collection and per-action level.</p>

      <p><mark>We will be using the initial bootstrap key that you started Typesense with (via <code>--api-key</code>>)
        to create additional keys. It's <strong>strongly recommended</strong> that you don't use the bootstrap
        API key directly in your production applications. Instead you want to generate an appropriately-scoped key for the application at hand.</mark>
      </p>

      <h4 id="create-key">Create an API Key</h4>

      <p>Let's begin by creating an API key that allows you to do all operations, i.e. it's effectively an admin key and
        is equivalent to the key that you start Typesense with (via <code>--api-key</code>). </p>

      {% code_block create-admin-key %}
      ```javascript
      key = client.keys().create({
        'description': 'Admin key.',
        'actions': ['*'],
        'collections': ['*']
      })
      ```

      ```php
      $key = $client->keys->create([
        'description' => 'Admin key.',
        'actions' => ['*'],
        'collections' => ['*']
      ])
      ```

      ```python
      key = client.keys.create({
        "description": "Admin key.",
        "actions": ["*"],
        "collections": ["*"]
      })
      ```

      ```ruby
      key = client.keys.create({
        'description' => 'Admin key.',
        'actions' => ['*'],
        'collections' => ['*']
      })
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X POST -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      -H 'Content-Type: application/json' \
      -d '{"description":"Admin key.","actions": ["*"], "collections": ["*"]}'
      ```
      {% endcode_block %}

      <p>By setting both <code>actions</code> and <code>collections</code> to a wildcard <code>['*']</code> scope,
        we're able to create an admin key that gives you universal access. However, you should refrain from creating
      such widely scoped keys. </p>

      <p><mark><strong>NOTE: </strong>The generated key is returned only during creation. You want to store this
        key carefully in a secure place.</mark></p>

      <p>Let's now see how we can create a search-only key that allows you to limit the
      key's scope to only the search action, and also for only a specific collection.</p>

      {% code_block create-search-key %}
      ```javascript
      client.keys().create({
        'description': 'Admin key.',
        'actions': ['documents:search'],
        'collections': ['companies']
      })
      ```

      ```php
      $client->keys->create([
        'description' => 'Search-only companies key.',
        'actions' => ['documents:search'],
        'collections' => ['companies']
      ])
      ```

      ```python
      client.keys.create({
        "description": "Search-only companies key.",
        "actions": ["documents:search"],
        "collections": ["companies"]
      })
      ```

      ```ruby
      client.keys.create({
        'description' => 'Search-only companies key.',
        'actions' => ['documents:search'],
        'collections' => ['companies']
      })
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X POST -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      -H 'Content-Type: application/json' \
      -d '{"description":"Search-only companies key.","actions": ["documents:search"], "collections": ["companies"]}'
      ```
      {% endcode_block %}

      <p>By setting the <code>actions</code> scope to <code>["documents:search"]</code> and the <code>collections</code>
      scope to <code>["companies"]</code>, we can generate a key that is allowed to only conduct searches on the
      <code>companies</code> collection.</p>

      <h5>Sample response</h5>

      {% code_block api-key-creation-response %}
      ```json
      {
        "actions": [
          "*"
        ],
        "collections": [
          "*"
        ],
        "description": "Admin key.",
        "id": 1,
        "value": "k8pX5hD0793d8YQC5aD1aEPd7VleSuGP"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>POST ${TYPESENSE_HOST}/keys</code></p>

      <h5>Sample actions</h5>

      <table class="table table-striped">
        <tr>
          <th>Action</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><code>documents:search</code></td>
          <td>
            <p>Allows only search requests.</p>
          </td>
        </tr>
        <tr>
          <td><code>documents:get</code></td>
          <td>
            <p>Allows fetching a single document.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:delete</code></td>
          <td>
            <p>Allows a collection to be deleted.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:create</code></td>
          <td>
            <p>Allows a collection to be created.</p>
          </td>
        </tr>
        <tr>
          <td><code>collections:*</code></td>
          <td>
            <p>Allow all kinds of collection related operations.</p>
          </td>
        </tr>
        <tr>
          <td><code>*</code></td>
          <td>
            <p>Allows all operations.</p>
          </td>
        </tr>
      </table>

      <h4 id="retrieve-key">Retrieve an API Key</h4>

      <p>Retrieve (metadata about) a key.</p>

      {% code_block retrieve-api-key %}
      ```javascript
      key = client.keys(1).retrieve()
      ```

      ```php
      $key = $client->keys[1]->retrieve()
      ```

      ```python
      key = client.keys[1].retrieve()
      ```

      ```ruby
      key = client.keys[1].retrieve
      ```

      ```shell
      curl 'http://localhost:8108/keys/1' -X GET -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-retrieval-response %}
      ```json
      {
        "actions": [ "documents:search" ],
        "collections": [ "*" ],
        "description": "Search-only key.",
        "id": 1,
        "value_prefix": "vxpx"
      }
      ```
      {% endcode_block %}

      <p>Notice how only the key prefix is returned when you retrieve a key. Due to security reasons, only the
          create endpoint returns the full API key.</p>

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/keys/:id</code></p>

      <h4 id="list-keys">List all keys</h4>

      <p>Retrieve (metadata about) all keys.</p>

      {% code_block list-all-keys %}
      ```javascript
      client.keys().retrieve()
      ```

      ```php
      $client->keys->retrieve()
      ```

      ```python
      client.keys.retrieve()
      ```

      ```ruby
      client.keys.retrieve
      ```

      ```shell
      curl 'http://localhost:8108/keys' -X GET -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block all-api-keys-retrieval-response %}
      ```json
      {
        "keys": [
          {
            "actions": [
              "documents:search"
            ],
            "collections": [
              "users"
            ],
            "description": "Search-only key.",
            "id": 1,
            "value_prefix": "iKBT"
          },
          {
            "actions": [
              "documents:search"
            ],
            "collections": [
              "users"
            ],
            "description": "Search-only key.",
            "id": 2,
            "value_prefix": "wst8"
          }
        ]
      }
      ```
      {% endcode_block %}

      <p>Notice how only the key prefix is returned when you retrieve a key. Due to security reasons, only the
        create endpoint returns the full API key.</p>

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/keys</code></p>

      <h4 id="delete-key">Delete API Key</h4>

      <p>Delete an API key given its ID.</p>

      {% code_block delete-api-key %}
      ```javascript
      key = client.keys(1).delete()
      ```

      ```php
      $key = $client->keys[1]->delete()
      ```

      ```python
      key = client.keys[1].delete()
      ```

      ```ruby
      key = client.keys[1].delete
      ```

      ```shell
      curl 'http://localhost:8108/keys/1' -X DELETE -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-deletion-response %}
      ```json
      {
        "id": 1
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/keys/:id</code></p>

      <h4 id="generate-scoped-search-key">Generate Scoped Search Key</h4>

      <p>
        You can generate scoped search API keys that have embedded search parameters in them. This is useful for example
        when you have multi-tenant data indexed in your Typesense instance, but only want your users to access their own subset of the data.
      </p>

      <p>To do this, you can embed a filter in a generated scoped search API key. When you use that key for search operations,
        those filters will get automatically applied and cannot be overriden.
      </p>

      <p>
        We can generate scoped search API keys without having to make any calls to the Typesense server. We use an API key
        that we previously generated with a search scope, create an HMAC digest of the parameters with this key and use that
        as the API key. Our client libraries handle this logic for you, but you can also generate scoped search API keys from the command line.
      </p>

      <p>
        <mark><strong>Note:</strong>
          Remember to never expose your main search key client-side, since exposing the main search key will allow anyone to query the entire data set
          without your embedded search parameters.
        </mark>
      </p>

      {% code_block generate-scoped-search-api-key %}
      ```javascript
      keyWithSearchPermissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generateScopedSearchKey(keyWithSearchPermissions, {'filter_by': 'company_id:124'})
      ```

      ```php
      $keyWithSearchPermissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      $client->keys()->generateScopedSearchKey($keyWithSearchPermissions, ['filter_by' => 'company_id:124'])
      ```

      ```python
      key_with_search_permissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generate_scoped_search_key(key_with_search_permissions, {"filter_by": "company_id:124"})
      ```

      ```ruby
      key_with_search_permissions = 'RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127'
      client.keys().generate_scoped_search_key(key_with_search_permissions, {'filter_by': 'company_id:124'})
      ```

      ```shell
      KEY_WITH_SEARCH_PERMISSIONS="RN23GFr1s6jQ9kgSNg2O7fYcAUXU7127"
      EMBEDDED_SEARCH_PARAMETERS_JSON='{"filter_by":"company_id:124"}'

      digest=$(echo -n $EMBEDDED_SEARCH_PARAMETERS_JSON | openssl dgst -sha256 -hmac $KEY_WITH_SEARCH_PERMISSIONS -binary | base64)

      scoped_api_key=$(echo -n "${digest}${KEY_WITH_SEARCH_PERMISSIONS:0:4}${EMBEDDED_SEARCH_PARAMETERS_JSON}" | base64)

      echo $scoped_api_key
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block api-key-deletion-response %}
      ```json
      "SC9sT0hncHFwTHNFc3U3d3psRDZBUGNXQUViQUdDNmRHSmJFQnNnczJ4VT1STjIzeyJmaWx0ZXJfYnkiOiJjb21wYW55X2lkOjEyNCJ9"
      ```
      {% endcode_block %}

      <h3 id="curation">Curation</h3>

      <p>While Typesense makes it really easy and intuitive to deliver great search results, sometimes you might
        want to promote certain documents over others. Or, you might want to exclude certain documents from a
        query's result set.</p>

      <p>Using overrides, you can include or exclude specific documents for a given query.</p>

      <h4 id="create-update-override">Create or update an override</h4>

      <p>In the following example, we are overriding the search results by placing the documents with ids <code>422</code>
        and <code>54</code> in the first and second positions respectively via the <code>includes</code> condition.
        Additionally, we're ensuring that the document with id <code>287</code> is not returned at all
        via the <code>excludes</code> condition. You need to specify only one of <code>exclude</code> or
        <code>include</code>.</p>

      <p>Note how we are applying these overrides to an <code>exact</code> match of the query <code>apple</code>.
        Instead, if we want to match all queries that contained the word <code>apple</code>, we will use
        the <code>contains</code> match instead.</p>

      {% code_block create-update-override %}
      ```javascript
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      // Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections('companies').overrides().upsert('customize-apple', override)
      ```

      ```php
      $override = [
        "rule" => [
          "query" => "apple",
          "match" => "exact"
        ],
        "includes" => [
          ["id" => "422", "position" => 1],
          ["id" => "54", "position" => 2]
        ],
        "excludes" => [
          ["id" => "287"]
        ]
      ]

      # Creates/updates an override called `customize-apple` in the `companies` collection
      $client->collections['companies']->overrides->upsert('customize-apple', $override)
      ```

      ```python
      override = {
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```ruby
      override = {
        "rule" => {
          "query" => "apple",
          "match" => "exact"
        },
        "includes" => [
          {"id" => "422", "position" => 1},
          {"id" => "54", "position" => 2}
        ],
        "excludes" => [
          {"id" => "287"}
        ]
      }

      # Creates/updates an override called `customize-apple` in the `companies` collection
      client.collections['companies'].overrides.upsert('customize-apple', override)
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X PUT \
      -H "Content-Type: application/json" \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
        "rule": {
          "query": "apple",
          "match": "exact"
        },
        "includes": [
          {"id": "422", "position": 1},
          {"id": "54", "position": 2}
        ],
        "excludes": [
          {"id": "287"}
        ]
      }'
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "id": "customize-apple",
        "excludes": [
          {
            "id": "287"
          }
        ],
        "includes": [
          {
            "id": "422",
            "position": 1
          },
          {
            "id": "54",
            "position": 2
          }
        ],
        "rule": {
          "match": "exact",
          "query": "apple"
        }
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>excludes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be excluded from the search results.</td>
        </tr>
        <tr>
          <td>includes</td>
          <td>no</td>
          <td>List of document <code>id</code>s that should be included in the search results with their
            corresponding <code>position</code>s.</td>
        </tr>
        <tr>
          <td>rule.query</td>
          <td>yes</td>
          <td>Indicates what search queries should be overridden.</td>
        </tr>
        <tr>
          <td>rule.match</td>
          <td>yes</td>
          <td>Indicates whether the match on the query term should be <code>exact</code> or <code>contains</code>.</td>
        </tr>
      </table>

      <hr />

      <h4 id="list-overrides">List all overrides</h4>

      <p>Listing all overrides associated with a given collection.</p>

      {% code_block list-overrides %}
      ```javascript
      client.collections('companies').overrides().retrieve
      ```

      ```php
      $client->collections['companies']->overrides->retrieve()
      ```

      ```python
      client.collections['companies'].overrides.retrieve()
      ```

      ```ruby
      client.collections['companies'].overrides.retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
      "http://localhost:8108/collections/companies/overrides"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "overrides":[
          {
            "id":"customize-apple",
            "excludes":[
              {
                "id":"287"
              }
            ],
            "includes":[
              {
                "id":"422",
                "position":1
              },
              {
                "id":"54",
                "position":2
              }
            ],
            "rule":{
              "match":"exact",
              "query":"apple"
            }
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/collections/:collection/overrides</code></p>

      <hr />

      <h4 id="delete-override">Delete an override</h4>

      <p>Deleting an override associated with a collection.</p>

      {% code_block delete-override %}
      ```javascript
      client.collections('companies').overrides('customize-apple').delete()
      ```

      ```php
      $client->collections['companies']->overrides['customize-apple'].delete()
      ```

      ```python
      client.collections['companies'].overrides['customize-apple'].delete()
      ```

      ```ruby
      client.collections['companies'].overrides['customize-apple'].delete
      ```

      ```shell
      curl "http://localhost:8108/collections/companies/overrides/customize-apple" -X DELETE \
      -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "id": "customize-apple"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/collections/:collection/overrides/:id</code></p>
      <hr />

      <h3 id="aliases">Collection Alias</h3>

      <p>An alias is a virtual collection name that points to a real collection. If you're familiar with
        symbolic links on Linux, it's very similar to that. </p>

      <p>Aliases are useful when you want to reindex your
        data in the background on a new collection and switch your application to it without any changes
        to your code. Let's take an example.</p>

      <p>Let's say we have a collection called <code>companies_june10</code> and an alias
         called <code>companies</code> pointing to that collection.</p>

      <p><code>collection ---> companies_june10</code></p>

      <p>On the next day (June 11), we will create a new collection called <code>companies_june11</code>
        and start indexing the documents in the background into this collection. When we are done indexing,
        if we updated the <code>companies</code> alias to point to this new collection,
        your application would immediately start querying against the freshly indexed collection.</p>

      <p><code>collection ---> companies_june11</code></p>

      <p>Convenient isn't it? Let's now look at how we can create, update and manage aliases.</p>

      <hr />

      <h4 id="create-update-alias">Create or Update an alias</h4>

      {% code_block create-update-alias %}
      ```javascript
        aliased_collection = {
          'collection_name': 'companies_june11'
        }

        // Creates/updates an alias called `companies` to the `companies_june11` collection
        client.aliases().upsert('companies', aliased_collection)
      ```

      ```php
          $aliasedCollection = [
            'collection_name' => 'companies_june11'
          ]

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          $client->aliases->upsert('companies', $aliasedCollection)
      ```

      ```python
          aliased_collection = {
            'collection_name': 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```ruby
          aliased_collection = {
            'collection_name' => 'companies_june11'
          }

          # Creates/updates an alias called `companies` to the `companies_june11` collection
          client.aliases.upsert('companies', aliased_collection)
      ```

      ```shell
        curl "http://localhost:8108/aliases/companies" -X PUT \
            -H "Content-Type: application/json" \
            -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" -d '{
                "collection_name": "companies_june11"
            }'
        ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11",
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>PUT ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <h5>Arguments</h5>

      <table class="table table-striped">
        <tr>
          <th>Parameter</th>
          <th>Required</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>collection_name</td>
          <td>yes</td>
          <td>Name of the collection you wish to map the alias to.</td>
        </tr>
      </table>

      <hr />

      <h4 id="retrieve-alias">Retrieve an alias</h4>

      <p>We can find out which collection an alias points to by fetching it.</p>

      {% code_block retrieve-alias %}
      ```javascript
        client.aliases('companies').retrieve()
      ```

      ```php
        $client->aliases['companies']->retrieve()
      ```

      ```python
        client.aliases['companies'].retrieve()
      ```

      ```ruby
        client.aliases['companies'].retrieve
      ```

      ```shell
        curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
            "http://localhost:8108/aliases/companies"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
        {
          "name": "companies",
          "collection_name": "companies_june11",
        }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <hr />

      <h4 id="list-aliases">List all aliases</h4>

      <p>List all aliases and the corresponding collections that they map to.</p>

      {% code_block list-aliases %}
      ```javascript
      client.aliases().retrieve()
      ```

      ```php
      $client->aliases->retrieve()
      ```

      ```python
      client.aliases.retrieve()
      ```

      ```ruby
      client.aliases.retrieve
      ```

      ```shell
      curl -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}" \
           "http://localhost:8108/aliases"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block get-alias-response %}
      ```json
      {
        "aliases": [
          {
            "name": "companies",
            "collection_name": "companies_june11"
          },
          {
            "name": "employees",
            "collection_name": "employees_june11"
          }
        ]
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>GET ${TYPESENSE_HOST}/aliases</code></p>

      <hr />

      <h4 id="delete-alias">Delete an alias</h4>

      {% code_block delete-alias %}
      ```javascript
        client.aliases('companies').delete()
      ```

      ```php
        $client->aliases['companies']->delete()
      ```

      ```python
        client.aliases['companies'].delete()
      ```

      ```ruby
        client.aliases['companies'].delete
      ```

      ```shell
      curl "http://localhost:8108/aliases/companies" -X DELETE
          -H "X-TYPESENSE-API-KEY: ${TYPESENSE_API_KEY}"
      ```
      {% endcode_block %}

      <h5>Sample response</h5>

      {% code_block delete-alias-response %}
      ```json
      {
        "name": "companies",
        "collection_name": "companies_june11"
      }
      ```
      {% endcode_block %}

      <h5>Definition</h5>
      <p><code>DELETE ${TYPESENSE_HOST}/aliases/:alias</code></p>

      <h3 id="whats-new">What's new in 0.15.0</h3>

      <p>This release contains several new features, bug fixes and performance improvements.</p>

      <ul>
        <li><strong>[Performance]</strong> Adopted jemalloc: we're now using jemalloc as the memory allocator.
          In our tests, jemalloc showed significantly better performance and lower memory fragmentation.</li>
        <li><strong>[Performance]</strong> Streaming import: You can now safely import large number of documents into
          Typesense without a drastic impact on search latency. We've also changed the output format of the
          import end-point: the response will now be in JSON lines rather than as a full-fledged JSON document.</li>
        <li><strong>[Performance]</strong> Significant performance improvement in wildcard queries and faceting
          involving array fields. </li>
        <li><strong>[Feature]</strong> Allow default sorting field to be an <code>int64</code>.</li>
        <li><strong>[Feature]</strong> Ensured that the server returns a <code>503</code> response when it is still
          catching up on the writes from the leader. This threshold can be controlled by
          the <code>--catch-up-threshold-percentage</code> argument (default: <code>95</code>).</li>
        <li><strong>[Feature]</strong> Data snapshot interval can now be customized by the
          <code>--snapshot-interval-seconds</code> argument (default: <code>3600</code>).</li>
        <li><strong>[Feature]</strong> Metrics API: we've added a <code>/metrics.json</code> end-point that
          returns CPU, storage and memory metrics.</li>
        <li><strong>[Feature]</strong> Exact filtering on string field: It's now possible to
          match a facet-enabled string field exactly in the filter query by using the <code>:=</code> operator. </li>
        <li><strong>[Bug fix]</strong> Clustering improvements: We've fixed a number of performance issues and
          edge cases by extensively benchmarking the clustering implementation via multi-region deployments.</li>
        <li><strong>[Bug fix]</strong> Fixed a race condition that sometimes prevented a Typesense node from
        recognizing custom generated API keys.</li>
        <li><strong>[Bug fix]</strong> Fixed an edge case in text match score calculation that caused relevancy
        issues on long queries.</li>
        <li><strong>[Bug fix]</strong> Fixed a crash that happened when an <code>int32</code> field was
          filtered by a number exceeding the range of a valid <code>int32</code> value.</li>
      </ul>

      <h3 id="errors">API errors</h3>

      <p>Typesense API uses standard HTTP response codes to indicate the success or failure of a request.</p>

      <p>Codes in the 2xx range indicate success, codes in the 4xx range indicate an error given the information provided
      (e.g. a required parameter was omitted), and codes in the 5xx range indicate an error with the Typesense service itself.
      </p>

      <table class="table table-striped">
        <tr>
          <th>Error Code</th>
          <th>Meaning</th>
        </tr>

        <tr>
          <td>400</td>
          <td>Bad Request - The request could not be understood due to malformed syntax.</td>
        </tr>

        <tr>
          <td>401</td>
          <td>Unauthorized - Your API key is wrong.</td>
        </tr>

        <tr>
          <td>404</td>
          <td>Not Found - The requested resource is not found.</td>
        </tr>

        <tr>
          <td>409</td>
          <td>Conflict - When a resource already exists.</td>
        </tr>

        <tr>
          <td>422</td>
          <td>Unprocessable Entity - Request is well-formed, but cannot be processed.</td>
        </tr>

        <tr>
          <td>503</td>
          <td>Service Unavailable - We’re temporarily offline. Please try again later.</td>
        </tr>
      </table>
  </div>

  <div class="col-md-1 row no-gutters"></div>

  <div class="col-md-3 row no-gutters">
      <nav id="navbar-docs" class="navbar navbar-light navbar-text">
        <nav class="nav nav-pills flex-column sticky-top">
          <a class="nav-link" href="#introduction">Introduction</a>
          <a class="nav-link" href="#api-clients">API clients</a>
          <a class="nav-link" href="#authentication">Authentication</a>
          <a class="nav-link" href="#usage">Usage</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-collection">Create a collection</a>
            <a class="nav-link ml-3 my-1" href="#index-document">Index a document</a>
            <a class="nav-link ml-3 my-1" href="#search-collection">Search a collection</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-document">Retrieve a document</a>
            <a class="nav-link ml-3 my-1" href="#delete-document">Delete a document</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-collection">Retrieve a collection</a>
            <a class="nav-link ml-3 my-1" href="#export-documents">Export documents</a>
            <a class="nav-link ml-3 my-1" href="#import-documents">Import documents</a>
            <a class="nav-link ml-3 my-1" href="#list-collection">List all collections</a>
            <a class="nav-link ml-3 my-1" href="#drop-collection">Drop a collection</a>
          </nav>
          <a class="nav-link collapsed" href="#api-keys">Manage API Keys </a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#create-key">Create a key</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-key">Retrieve a key</a>
            <a class="nav-link ml-3 my-1" href="#list-keys">List all keys</a>
            <a class="nav-link ml-3 my-1" href="#delete-key">Delete a key</a>
            <a class="nav-link ml-3 my-1" href="#generate-scoped-search-key">Generate scoped search key</a>
          </nav>
          <a class="nav-link collapsed" href="#curation">Curation / Merchandizing </a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#curation">Create/Update an override</a>
            <a class="nav-link ml-3 my-1" href="#list-overrides">List all overrides</a>
            <a class="nav-link ml-3 my-1" href="#delete-override">Delete an override</a>
          </nav>
          <a class="nav-link collapsed" href="#aliases">Collection Alias</a>
          <nav class="nav nav-pills flex-column">
            <a class="nav-link ml-3 my-1" href="#aliases">Create/Update an alias</a>
            <a class="nav-link ml-3 my-1" href="#retrieve-alias">Retrieve an alias</a>
            <a class="nav-link ml-3 my-1" href="#list-aliases">List all aliases</a>
            <a class="nav-link ml-3 my-1" href="#delete-alias">Delete an alias</a>
          </nav>
          <a class="nav-link" href="#whats-new">What's new in 0.15.0</a>
          <a class="nav-link" href="#errors">API errors</a>
        </nav>
      </nav>
  </div>
</div>
